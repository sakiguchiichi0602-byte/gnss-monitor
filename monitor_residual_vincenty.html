<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GNSS 総合モニター (Vincenty)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.js"></script>

    <style>
        /* CSSは前回のコードから変更ありません */
        body { 
            font-family: sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center;
            max-width: 100vw;
            overflow-x: hidden;
        }
        h1 { margin: 10px 0; }
        #status { 
            width: 98vw; 
            padding: 10px; 
            background-color: #eee; 
            border-radius: 5px; 
            font-weight: bold; 
            box-sizing: border-box; 
        }
        #status.error { background-color: #ffdddd; color: #d8000c; }
        #status.success { background-color: #ddffdd; color: #008000; }
        
        #main-container {
            display: flex;
            flex-direction: row; 
            width: 98vw; 
            height: 80vh; 
            margin-top: 10px;
        }
        #left-column {
            width: 75%; 
            display: flex;
            flex-direction: column; 
            height: 100%;
            min-width: 0; 
        }
        #right-column {
            width: 25%; 
            height: 100%;
            padding-left: 10px;
            box-sizing: border-box;
            min-width: 0; 
        }
        .chart-container {
            position: relative;
            width: 100%;
            height: 100%; 
            min-height: 150px; 
            border: 1px solid #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden; 
        }
        #scatter-container { 
            height: 100%; 
            margin-bottom: 0; 
        }
        canvas { max-height: 100%; }
    </style>
</head>
<body>
    <h1>GNSS 総合モニター (残差・距離)</h1>
    <div id="status">MQTTブローカーに接続中...</div>
    
    <div id="main-container">
        <div id="left-column">
            <div class="chart-container" style="flex: 1.2;">
                <canvas id="residualChart"></canvas>
            </div>
            <div class="chart-container" style="flex: 1;">
                <canvas id="distanceChart"></canvas>
            </div>
            <div class="chart-container" style="flex: 1; margin-bottom: 0;">
                <canvas id="heightChart"></canvas>
            </div>
        </div>
        
        <div id="right-column">
            <div class="chart-container" id="scatter-container">
                <canvas id="scatterChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        // --- ★★★★★ 設定項目 (変更なし) ★★★★★ ---
        const MQTT_HOST = "249e081497cc4102b789e090b4e02268.s1.eu.hivemq.cloud";
        const MQTT_PORT = 8884;
        const MQTT_USERNAME = "irie_lab";
        const MQTT_PASSWORD = "Suya2659";
        const MQTT_TOPIC_RESIDUALS = "gnss/raspi/sbf-rtk-residuals";
        const MQTT_TOPIC_POSITION = "gnss/raspi/position-llh";
        // -------------------------------------------------------------

        // --- データ点数 60 (変更なし) ---
        const MAX_POINTS = 300; 
        
        const GPS_EPOCH_MS = new Date('1980-01-06T00:00:00Z').getTime();
        const statusDiv = document.getElementById('status');
        
        // --- 色・スタイル・品質定義 (変更なし) ---
        const satColors = new Map();
        let colorIndex = 0;
        const available_colors = ['#E6194B', '#3CB44B', '#4363D8', '#F58231', '#911EB4', '#46F0F0', '#F032E6', '#BCF60C', '#008080', '#E6BEFF', '#9A6324', '#800000', '#000075'];
        function getSatColor(sat_id) {
            if (!satColors.has(sat_id)) {
                satColors.set(sat_id, available_colors[colorIndex % available_colors.length]);
                colorIndex++;
            }
            return satColors.get(sat_id);
        }
        function getLineStyle(freq_id) {
            const id_str = String(freq_id);
            if (id_str === '2') return [5, 5];
            if (id_str === '5' || id_str === '7') return [2, 2];
            return [];
        }
        const qualityMap = { 0: "無効", 1: "RTK Fixed (Q=1)", 2: "RTK Float (Q=2)", 3: "SBAS (Q=3)", 4: "DGPS (Q=4)", 5: "SPS (Q=5)" };
        const qualityColor = { 0: "#999", 1: "#3CB44B", 2: "#E6194B", 3: "#911EB4", 4: "#4363D8", 5: "#F58231" };
        
        function updateStatus(message, isError = false) {
            console.log(message);
            statusDiv.textContent = message;
            if (isError) { statusDiv.className = 'error'; }
            else { statusDiv.className = (message.includes("接続しました")) ? 'success' : ''; }
        }

        // --- ヴィンセンティー法 (Vincenty) 関数 (変更なし) ---
        function calculateVincentyDistance(lat1, lon1, lat2, lon2) {
            function toRad(deg) { return deg * Math.PI / 180; }
            const a = 6378137.0, f = 1 / 298.257223563, b = (1 - f) * a;
            const L = toRad(lon2 - lon1);
            const U1 = Math.atan((1 - f) * Math.tan(toRad(lat1)));
            const U2 = Math.atan((1 - f) * Math.tan(toRad(lat2)));
            const sinU1 = Math.sin(U1), cosU1 = Math.cos(U1);
            const sinU2 = Math.sin(U2), cosU2 = Math.cos(U2);
            let lambda = L, lambdaP, iterLimit = 100;
            let cosSqAlpha, sinSigma, cosSigma, cos2SigmaM, sigma;
            do {
                const sinLambda = Math.sin(lambda), cosLambda = Math.cos(lambda);
                sinSigma = Math.sqrt(Math.pow(cosU2 * sinLambda, 2) + 
                                     Math.pow(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda, 2));
                if (sinSigma === 0) return 0; 
                cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
                sigma = Math.atan2(sinSigma, cosSigma);
                const sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
                cosSqAlpha = 1 - Math.pow(sinAlpha, 2);
                if (cosSqAlpha === 0) { cos2SigmaM = 0; }
                else { cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha; }
                const C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
                lambdaP = lambda;
                lambda = L + (1 - C) * f * sinAlpha * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * Math.pow(cos2SigmaM, 2))));
            } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
            if (iterLimit === 0) return NaN; 
            const uSq = cosSqAlpha * (a * a - b * b) / (b * b);
            const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
            const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
            const deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * Math.pow(cos2SigmaM, 2)) -
                             B / 6 * cos2SigmaM * (-3 + 4 * Math.pow(sinSigma, 2)) * (-3 + 4 * Math.pow(cos2SigmaM, 2))));
            const s = b * A * (sigma - deltaSigma);
            return s; // 距離 (m)
        }
        
        // --- データ保持 (変更なし) ---
        const satDataSets = new Map(); 
        let basePosition = null; 
        const posData = { t: [], dist_m: [], h_abs: [] };
        const posScatterData = []; 

        // --- Chart.js 初期化 (X軸同期設定) (変更なし) ---
        const commonXAxisOptions = {
            type: 'time',
            time: {
                unit: 'second',
                displayFormats: { second: 'HH:mm:ss' }
            },
            ticks: { display: false },
            grid: { drawOnChartArea: false }
        };
        
        const ctxRes = document.getElementById('residualChart').getContext('2d');
        const residualChart = new Chart(ctxRes, { 
            type: 'line', data: { datasets: [] },
            options: { responsive: true, maintainAspectRatio: false,
                scales: { 
                    x: { ...commonXAxisOptions }, 
                    y: { title: { display: true, text: '残差 (m)' } } 
                },
                plugins: { title: { display: true, text: 'GPS衛星 疑似距離残差 (リアルタイム)' } }
            }
        });

        const ctxDist = document.getElementById('distanceChart').getContext('2d');
        const distanceChart = new Chart(ctxDist, { // 2. 水平距離
            type: 'line',
            data: {
                labels: [], 
                datasets: [
                    { label: '水平距離 (m)', data: [], borderColor: '#911EB4', borderWidth: 2, pointRadius: 0, tension: 0.1 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false,
                scales: { 
                    x: { ...commonXAxisOptions }, 
                    y: { title: { display: true, text: '距離 (m)' } }
                },
                plugins: { title: { display: true, text: '時間 - 水平距離 (基準点から)' } }
            }
        });

        const ctxHeight = document.getElementById('heightChart').getContext('2d');
        const heightChart = new Chart(ctxHeight, { // 3. 高さ
            type: 'line',
            data: {
                labels: [], 
                datasets: [
                    { label: '高さ (m)', data: [], borderColor: '#F58231', borderWidth: 2, pointRadius: 0, tension: 0.1 }
                ]
            },
            options: { responsive: true, maintainAspectRatio: false,
                scales: { 
                    x: { 
                        type: 'time',
                        time: {
                            unit: 'second',
                            displayFormats: { second: 'HH:mm:ss' }
                        },
                        ticks: { display: true } 
                    }, 
                    y: { title: { display: true, text: '高さ (m)' } } 
                },
                plugins: { title: { display: true, text: '時間 - 高さ' } }
            }
        });

        const ctxScatter = document.getElementById('scatterChart').getContext('2d');
        const scatterChart = new Chart(ctxScatter, { // 4. 散布図
            type: 'scatter',
            data: {
                // ★ 変更: 「基準点」を配列の最後に移動
                datasets: [ 
                    { label: '軌跡 (Path)', data: [], borderColor: '#aaaaaa', borderWidth: 1, pointRadius: 0, showLine: true, tension: 0.1 }, // 0
                    { label: 'RTK Fixed (Q=1)', data: [], backgroundColor: qualityColor[1], pointRadius: 3, showLine: false }, // 1
                    { label: 'RTK Float (Q=2)', data: [], backgroundColor: qualityColor[2], pointRadius: 3, showLine: false }, // 2
                    { label: 'SPS (Q=5)', data: [], backgroundColor: qualityColor[5], pointRadius: 3, showLine: false }, // 3
                    { label: 'DGPS (Q=4)', data: [], backgroundColor: qualityColor[4], pointRadius: 3, showLine: false }, // 4
                    { label: '無効 (Q=0)', data: [], backgroundColor: qualityColor[0], pointRadius: 3, showLine: false }, // 5
                    { label: '基準点', data: [], backgroundColor: '#0000FF', pointRadius: 6, pointStyle: 'star', showLine: false }  // 6 (一番上)
                ]
            },
            options: { responsive: true, maintainAspectRatio: true, aspectRatio: 1, 
                scales: { 
                    x: { title: { display: true, text: '経度 (度)' }, grid: { color: '#ccc' } }, 
                    y: { title: { display: true, text: '緯度 (度)' }, grid: { color: '#ccc' } } 
                },
                plugins: { title: { display: true, text: '水平位置 (Lat vs Lon)' } }
            }
        });

        // --- MQTTクライアント初期化 (変更なし) ---
        const clientID = "gnss_web_monitor_vincenty_" + new Date().getTime();
        const client = new Paho.Client(MQTT_HOST, MQTT_PORT, clientID); 

        client.onConnectionLost = (responseObject) => {
            if (responseObject.errorCode !== 0) {
                updateStatus(`MQTT接続が切れました: ${responseObject.errorMessage}。5秒後に再接続します...`, true);
                setTimeout(startConnect, 5000);
            }
        };

        // --- メッセージ受信 (変更なし) ---
        client.onMessageArrived = (message) => {
            try {
                if (message.destinationName === MQTT_TOPIC_RESIDUALS) {
                    handleResidualMessage(message.payloadString);
                }
                else if (message.destinationName === MQTT_TOPIC_POSITION) {
                    handlePositionMessage(message.payloadString);
                }
            } catch (e) {
                console.error(`データ解析エラー: ${e}`, message.payloadString);
            }
        };
        
        // --- 残差メッセージ処理 (変更なし) ---
        function handleResidualMessage(line) {
            const parts = line.split(',');
            if (parts.length < 5) return; 
            const week = parseInt(parts[0]);
            const gpst_sec = parseFloat(parts[1]);
            const utc_ms = GPS_EPOCH_MS + (week * 7 * 24 * 60 * 60 * 1000) + (gpst_sec * 1000);
            const timestamp = new Date(utc_ms); 
            const sat_id = parts[2];
            const freq_id = parts[3];
            const residual_val = parseFloat(parts[4]);
            if (isNaN(residual_val)) return; 
            const key = `${sat_id} (L${freq_id})`;
            
            let dataset = satDataSets.get(key);
            if (!dataset) {
                dataset = {
                    label: key, data: [],
                    borderColor: getSatColor(sat_id), borderDash: getLineStyle(freq_id),
                    borderWidth: 2, pointRadius: 0, tension: 0.1
                };
                satDataSets.set(key, dataset);
                residualChart.data.datasets.push(dataset);
            }
            
            const newDataPoint = { x: timestamp, y: residual_val };
            dataset.data.push(newDataPoint);
        }

        // --- ★ 変更: 位置メッセージ処理 (軸固定 + 基準点インデックス変更) ---
        function handlePositionMessage(line) {
            const parts = line.split(',');
            if (parts.length < 5) return;
            
            const timestamp = new Date(parseFloat(parts[0]) * 1000);
            const lat_dd = parseFloat(parts[1]);
            const lon_dd = parseFloat(parts[2]);
            const height = parseFloat(parts[3]);
            const quality = parseInt(parts[4]); 
            
            if (isNaN(lat_dd) || quality === 0) return; 

            // 1. 基準点が未設定の場合
            if (!basePosition && quality > 0) {
                basePosition = { lat: lat_dd, lon: lon_dd, h: height };
                console.log("基準点を設定:", basePosition);
                
                // ★ 変更: 散布図に基準点をプロット (dataset[6])
                scatterChart.data.datasets[6].data = [{ x: lon_dd, y: lat_dd }];
                
                // ★ 変更: 散布図の軸を「固定」 (SPSの誤差がわかる 0.0005度 バッファ)
                const buffer = 0.00007; // 約 ±7m の範囲
                scatterChart.options.scales.x.min = lon_dd - buffer;
                scatterChart.options.scales.x.max = lon_dd + buffer;
                scatterChart.options.scales.y.min = lat_dd - buffer;
                scatterChart.options.scales.y.max = lat_dd + buffer;
                
                scatterChart.update('none'); 
                return; 
            }
            
            // 2. 基準点が設定済みの場合 (変更なし)
            if (basePosition) {
                const distance = calculateVincentyDistance(basePosition.lat, basePosition.lon, lat_dd, lon_dd);

                posData.t.push(timestamp);
                posData.dist_m.push(distance); // 水平距離
                posData.h_abs.push(height);    // 絶対高さ
                
                const scatterPoint = { x: lon_dd, y: lat_dd, q: quality }; 
                posScatterData.push(scatterPoint);

                if (posData.t.length > MAX_POINTS) {
                    posData.t.shift(); 
                    posData.dist_m.shift(); 
                    posData.h_abs.shift();
                }
                if (posScatterData.length > MAX_POINTS) {
                    posScatterData.shift();
                }
            }
        }

        // --- 接続処理 (変更なし) ---
        function startConnect() {
            updateStatus(`MQTTブローカー (${MQTT_HOST}:${MQTT_PORT}) に接続中...`);
            client.connect({
                userName: MQTT_USERNAME,
                password: MQTT_PASSWORD,
                useSSL: true, 
                onSuccess: () => {
                    updateStatus(`MQTTブローカーに接続しました。トピックの購読を開始します...`, false);
                    client.subscribe(MQTT_TOPIC_RESIDUALS);
                    client.subscribe(MQTT_TOPIC_POSITION); 
                },
                onFailure: (response) => {
                    updateStatus(`MQTT接続に失敗: ${response.errorMessage}`, true);
                }
            });
        }
        
        // --- ★ 変更: グラフ更新ループ (X軸同期 + 散布図インデックス変更) ---
        setInterval(() => {
            if (!client.isConnected()) return;

            // 1. X軸同期 (右からプロットされる) (変更なし)
            let timeMin = null;
            let timeMax = null;
            if (posData.t.length > 0) {
                 const lastTime = posData.t[posData.t.length - 1].getTime();
                 timeMin = lastTime - (MAX_POINTS * 1000); 
                 timeMax = lastTime; 
            }

            // 2. 残差グラフ (変更なし)
            if (timeMin) {
                residualChart.options.scales.x.min = timeMin;
                residualChart.options.scales.x.max = timeMax;
            }
            const activeDatasets = [];
            const activeTimeLimit = new Date().getTime() - 60000; 
            for (const [key, dataset] of satDataSets.entries()) {
                 if (timeMin) {
                    while(dataset.data.length > 0 && dataset.data[0].x.getTime() < timeMin) {
                        dataset.data.shift();
                    }
                 }
                if (dataset.data.length > 0 && dataset.data[dataset.data.length - 1].x.getTime() > activeTimeLimit) {
                     activeDatasets.push(dataset);
                }
            }
            residualChart.data.datasets = activeDatasets;
            residualChart.update('none');
            
            // 3. 水平距離グラフ (変更なし)
            if (timeMin) {
                distanceChart.options.scales.x.min = timeMin;
                distanceChart.options.scales.x.max = timeMax;
            }
            distanceChart.data.datasets[0].data = posData.dist_m.map((val, idx) => ({ x: posData.t[idx], y: val }));
            distanceChart.update('none');
            
            // 4. 高さグラフ (変更なし)
            if (timeMin) {
                heightChart.options.scales.x.min = timeMin;
                heightChart.options.scales.x.max = timeMax;
            }
            heightChart.data.datasets[0].data = posData.h_abs.map((val, idx) => ({ x: posData.t[idx], y: val }));
            heightChart.update('none');

            // 5. 散布図
            // 軌跡 (dataset 0)
            scatterChart.data.datasets[0].data = posScatterData.map(p => ({x: p.x, y: p.y}));
            
            // ★ 変更: 品質ごとの点 (datasets 1-5)
            const qualityData = { 1: [], 2: [], 5: [], 4: [], 0: [] };
            posScatterData.forEach(p => {
                const q = p.q || 0;
                if (qualityData[q]) qualityData[q].push({x: p.x, y: p.y});
            });
            scatterChart.data.datasets[1].data = qualityData[1]; // Fixed
            scatterChart.data.datasets[2].data = qualityData[2]; // Float
            scatterChart.data.datasets[3].data = qualityData[5]; // SPS
            scatterChart.data.datasets[4].data = qualityData[4]; // DGPS
            scatterChart.data.datasets[5].data = qualityData[0]; // 無効
            
            // (基準点 (dataset 6) は 1回しか設定しない)
            scatterChart.update('none');

        }, 1000); 

        // --- 実行開始 ---
        startConnect();

    </script>
</body>
</html>
</body>
</html>
