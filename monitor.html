<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GNSS 残差モニター (Streaming)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.1.0/paho-mqtt.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-streaming@2.0.0/dist/chartjs-plugin-streaming.min.js"></script>

    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        #chart-container { position: relative; width: 90vw; height: 70vh; margin-top: 20px; }
        #status { width: 90vw; padding: 10px; background-color: #eee; border-radius: 5px; font-weight: bold; }
        #status.error { background-color: #ffdddd; color: #d8000c; }
        #status.success { background-color: #ddffdd; color: #008000; }
    </style>
</head>
<body>
    <h1>GNSS 疑似距離残差 (リアルタイム)</h1>
    <div id="status">MQTTブローカーに接続中...</div>
    <div id="chart-container">
        <canvas id="residualChart"></canvas>
    </div>

    <script>
        // --- ★★★★★ 設定項目 (変更なし) ★★★★★ ---
        const MQTT_HOST = "249e081497cc4102b789e090b4e02268.s1.eu.hivemq.cloud";
        const MQTT_PORT = 8884;
        const MQTT_TOPIC = "gnss/raspi/sbf-rtk-residuals";
        const MQTT_USERNAME = "irie_lab";
        const MQTT_PASSWORD = "Suya2659";
        // -------------------------------------------------------------

        // --- インデックスと定数 (変更なし) ---
        const IDX_WEEK = 0, IDX_GPST_SEC = 1, IDX_SAT_ID = 2, IDX_FREQ_ID = 3, IDX_RES_CODE = 4;
        const GPS_EPOCH_MS = new Date('1980-01-06T00:00:00Z').getTime();
        const PLOT_DURATION_MS = 2 * 60 * 60 * 1000; // 2時間 (ミリ秒)
        const statusDiv = document.getElementById('status');
        
        // --- 色とスタイルの管理 (変更なし) ---
        const satColors = new Map();
        let colorIndex = 0;
        const available_colors = [
            '#E6194B', '#3CB44B', '#4363D8', '#F58231', '#911EB4', '#46F0F0', 
            '#F032E6', '#BCF60C', '#FABEBE', '#008080', '#E6BEFF', '#9A6324',
            '#FFFAC8', '#800000', '#AAFFC3', '#808000', '#FFD8B1', '#000075'
        ];
        function getSatColor(sat_id) {
            if (!satColors.has(sat_id)) {
                satColors.set(sat_id, available_colors[colorIndex % available_colors.length]);
                colorIndex++;
            }
            return satColors.get(sat_id);
        }
        function getLineStyle(freq_id) {
            const id_str = String(freq_id);
            if (id_str === '2') return [5, 5]; // 破線
            if (id_str === '5' || id_str === '7') return [2, 2]; // 点線
            return []; // 実線
        }
        
        function updateStatus(message, isError = false) {
            console.log(message);
            statusDiv.textContent = message;
            if (isError) { statusDiv.className = 'error'; }
            else { statusDiv.className = (message.includes("接続しました")) ? 'success' : ''; }
        }

        // --- 1. Chart.js の初期化 (★ ストリーミング用にオプションを変更) ---
        const ctx = document.getElementById('residualChart').getContext('2d');
        const residualChart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [] // ここに動的にデータセットが追加される
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        // ★ 変更: 'time' から 'realtime' に変更
                        type: 'realtime', 
                        title: { display: true, text: '時刻 (JST)' },
                        // ★ 変更: プラグイン設定を追加
                        realtime: {
                            // 表示する時間範囲 (ミリ秒)
                            duration: PLOT_DURATION_MS,
                            // 新しいデータが来るまで待機する時間
                            refresh: 1000, 
                            // グラフが右端に到達してからスクロールするまでの遅延
                            delay: 2000, 
                            // ★重要: データが来たら自動でグラフを更新
                            pause: false,
                            
                            // ★ 変更: メッセージ受信(onMessageArrived)でデータを追加
                            // onRefresh: chart => { /* このデモでは不要 */ }
                        },
                        time: {
                            unit: 'minute',
                            tooltipFormat: 'HH:mm:ss',
                            displayFormats: { minute: 'HH:mm', hour: 'HH:mm' }
                        }
                    },
                    y: {
                        title: { display: true, text: '残差 (m)' },
                        suggestedMin: -0.5,
                        suggestedMax: 0.5
                    }
                },
                plugins: {
                    legend: { position: 'top' },
                    title: { display: true, text: 'GPS衛星 疑似距離残差 (リアルタイム)' }
                }
            }
        });

        // --- 2. MQTTクライアントの初期化と接続 ---
        const clientID = "gnss_web_monitor_streaming_" + new Date().getTime();
        
        // ★ 変更: Paho.MQTT.Client -> Paho.Client (前回修正済み)
        const client = new Paho.Client(MQTT_HOST, MQTT_PORT, clientID);

        client.onConnectionLost = (responseObject) => {
            if (responseObject.errorCode !== 0) {
                updateStatus(`MQTT接続が切れました: ${responseObject.errorMessage}。5秒後に再接続します...`, true);
                setTimeout(startConnect, 5000);
            }
        };

        // --- 3. メッセージ受信時の処理 (★ 変更: ロジックを簡素化) ---
        client.onMessageArrived = (message) => {
            try {
                const line = message.payloadString;
                const parts = line.split(',');
                if (parts.length < 5) return; 

                // 1. タイムスタンプ計算 (変更なし)
                const week = parseInt(parts[IDX_WEEK]);
                const gpst_sec = parseFloat(parts[IDX_GPST_SEC]);
                const utc_ms = GPS_EPOCH_MS + (week * 7 * 24 * 60 * 60 * 1000) + (gpst_sec * 1000);
                const timestamp = new Date(utc_ms); 

                // 2. 衛星ID, 周波数ID (変更なし)
                const sat_id = parts[IDX_SAT_ID];
                const freq_id = parts[IDX_FREQ_ID];
                
                // 3. 残差 (変更なし)
                const residual_val = parseFloat(parts[IDX_RES_CODE]);
                if (isNaN(residual_val)) return; 

                const key = `${sat_id} (L${freq_id})`;

                // 4. Chart.js用のデータポイントを作成 (変更なし)
                const newDataPoint = {
                    x: timestamp,
                    y: residual_val
                };

                // 5. ★ 変更: 該当するデータセットを探す (Chartオブジェクトから直接探す)
                let dataset = residualChart.data.datasets.find(ds => ds.label === key);

                if (!dataset) {
                    // データセットがなければ、新しく作成 (変更なし)
                    dataset = {
                        label: key,
                        data: [],
                        borderColor: getSatColor(sat_id),
                        borderDash: getLineStyle(freq_id),
                        borderWidth: 2,
                        pointRadius: 0, 
                        tension: 0.1
                    };
                    // グラフに新しいデータセットとして追加 (変更なし)
                    residualChart.data.datasets.push(dataset);
                }

                // 6. ★ 変更: データを追加 (プラグインが自動で古いデータを削除)
                dataset.data.push(newDataPoint);
                
                // ★ 削除: MAX_POINTSの管理と shift() ロジックは不要になった
                
            } catch (e) {
                console.error(`データ解析エラー: ${e}`, line);
            }
        };

        // --- 4. 接続処理 (変更なし) ---
        function startConnect() {
            updateStatus(`MQTTブローカー (${MQTT_HOST}:${MQTT_PORT}) に接続中...`);
            client.connect({
                userName: MQTT_USERNAME,
                password: MQTT_PASSWORD,
                useSSL: true, 
                onSuccess: () => {
                    updateStatus(`MQTTブローカーに接続しました。トピック '${MQTT_TOPIC}' の購読を開始します...`, false);
                    client.subscribe(MQTT_TOPIC);
                },
                onFailure: (response) => {
                    updateStatus(`MQTT接続に失敗: ${response.errorMessage}`, true);
                }
            });
        }
        
        // --- 5. ★ 削除: グラフの更新ループは不要 ---
        // 1秒ごとの setInterval(residualChart.update) は、
        // ストリーミングプラグインが自動で行うため、削除します。

        // --- 実行開始 ---
        startConnect();

    </script>
</body>
</html>